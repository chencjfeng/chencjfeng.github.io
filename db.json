{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/Anisina/source/css/syntax.styl","path":"css/syntax.styl","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/blog-style.css","path":"css/blog-style.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","path":"fonts/glyphicons-halflings-regular.eot","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","path":"fonts/glyphicons-halflings-regular.ttf","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","path":"fonts/glyphicons-halflings-regular.woff","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","path":"fonts/glyphicons-halflings-regular.woff2","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/header.jpg","path":"images/header.jpg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/blog.js","path":"js/blog.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/bootstrap.min.js","path":"js/bootstrap.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","path":"js/jquery.tagcloud.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/css/bootstrap.min.css","path":"css/bootstrap.min.css","modified":0,"renderable":1},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","path":"fonts/glyphicons-halflings-regular.svg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.min.js","path":"js/jquery.min.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/earth.jpg","path":"images/earth.jpg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/js/jquery.js","path":"js/jquery.js","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/blog-bg-black-run.jpg","path":"images/blog-bg-black-run.jpg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/post_default_one.png","path":"images/post_default_one.png","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/post_default.jpg","path":"images/post_default.jpg","modified":0,"renderable":1},{"_id":"themes/Anisina/source/images/post_default_two.png","path":"images/post_default_two.png","modified":0,"renderable":1}],"Cache":[{"_id":"themes/Anisina/.DS_Store","hash":"7db9688588f08844708f20eb215bd9ae28468e16","modified":1521163316664},{"_id":"themes/Anisina/LICENSE","hash":"2b209f06bebeb2a8c2b7e187e436f3e1e1fbc8a7","modified":1521163316665},{"_id":"themes/Anisina/README.md","hash":"ebde4101f083169abf82f5d9aa6fa34959d5cf11","modified":1521163316665},{"_id":"source/.DS_Store","hash":"4a36dc50713f24ff9794a9a44f59d5c346a21b0d","modified":1521163316662},{"_id":"themes/Anisina/_config.yml","hash":"06bccfc42b143659f59ea78938f00c217ac5574d","modified":1521163316676},{"_id":"themes/Anisina/package.json","hash":"12541fbf56f785e4f5d486a55b4939f3033f625b","modified":1521163316679},{"_id":"source/_posts/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521163316662},{"_id":"source/_posts/软件设计师考点内容-一.md","hash":"688a0e9f335e41670471ce650c3defd0522aed27","modified":1521163316664},{"_id":"source/_posts/软件设计师考点内容-三.md","hash":"469e0ea08eed81fd534b5f3f5925f880c99479db","modified":1521171700231},{"_id":"source/_posts/git-pull冲突解决.md","hash":"f6d826a38f968263c51d68bfa68b43fb46d870f1","modified":1521163316663},{"_id":"source/_posts/Python批量生成二维码.md","hash":"cad34d37d24c66cfff6edbe320f9f93557cb4af2","modified":1521163316663},{"_id":"source/tags/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1521163316664},{"_id":"source/tags/index.md","hash":"d31abafee7a4fa790b84ee0038f83113abcf11d5","modified":1521163316664},{"_id":"source/archives/index.md","hash":"3988ac8fdf49da191a412e1cfb4b919e08286266","modified":1521163316664},{"_id":"source/_posts/软件设计师考点内容-二.md","hash":"784e2e47b5699fecb3061c4e41617687c08fae32","modified":1521171043882},{"_id":"themes/Anisina/Screenshots/mobile-index.jpeg","hash":"cd75f77f5d865d42182e2233e354eeba9f114d98","modified":1521163316666},{"_id":"themes/Anisina/languages_to_be_added/de.yml","hash":"424a9c1e6ab69334d7873f6574da02ca960aa572","modified":1521163316676},{"_id":"themes/Anisina/languages_to_be_added/es.yml","hash":"cb4eeca0ed3768a77e0cd216300f2b2549628b1b","modified":1521163316677},{"_id":"themes/Anisina/languages_to_be_added/en.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1521163316677},{"_id":"themes/Anisina/languages_to_be_added/default.yml","hash":"97326c9e6518d9f379778178b3b8f9a58434725d","modified":1521163316676},{"_id":"themes/Anisina/languages_to_be_added/no.yml","hash":"8ca475a3b4f8efe6603030f0013aae39668230e1","modified":1521163316677},{"_id":"themes/Anisina/languages_to_be_added/zh-CN.yml","hash":"33213b0d940cc5df384f8376151616574ff67fe1","modified":1521163316677},{"_id":"themes/Anisina/languages_to_be_added/ru.yml","hash":"42df7afeb7a35dc46d272b7f4fb880a9d9ebcaa5","modified":1521163316677},{"_id":"themes/Anisina/languages_to_be_added/pl.yml","hash":"de7eb5850ae65ba7638e907c805fea90617a988c","modified":1521163316677},{"_id":"themes/Anisina/layout/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1521163316677},{"_id":"themes/Anisina/layout/404.ejs","hash":"1fe05722bd1b32bbe0ae4e3e880866f935e0ae11","modified":1521163316678},{"_id":"themes/Anisina/languages_to_be_added/zh-TW.yml","hash":"9acac6cc4f8002c3fa53ff69fb8cf66c915bd016","modified":1521163316677},{"_id":"themes/Anisina/layout/about.ejs","hash":"71adae5f8b145c86eb3587bdc581347367e72c10","modified":1521163316678},{"_id":"themes/Anisina/layout/index.ejs","hash":"6820c011dc7b05d1a838d784e303b348b6426aee","modified":1521163316678},{"_id":"themes/Anisina/layout/layout.ejs","hash":"9d3d82a707b107f42db34ef5a8016693da2be742","modified":1521163316679},{"_id":"themes/Anisina/layout/page.ejs","hash":"d02762ca539942d8046175d90bdb9e1bb212db67","modified":1521163316679},{"_id":"themes/Anisina/layout/poetry.ejs","hash":"6c955d419050825e13d39c780d45aceafbf6552d","modified":1521163316679},{"_id":"themes/Anisina/layout/post.ejs","hash":"07a81a2b5c3cdb0692935e4a876219e5a5c645bd","modified":1521163316679},{"_id":"themes/Anisina/layout/works.ejs","hash":"1df954e54098cc4845295836374abed870789dcd","modified":1521163316679},{"_id":"themes/Anisina/layout/archive.ejs","hash":"264d6875d2758b8e918a1c9556f85351d5bd41c1","modified":1521166755785},{"_id":"themes/Anisina/source/.DS_Store","hash":"c01ed1d6e12fe12b962860fc4fea984b64f67352","modified":1521163316680},{"_id":"themes/Anisina/layout/m_page.ejs","hash":"c0cb80b2367b40f3b300e387367f289e999f8ad6","modified":1521179647263},{"_id":"themes/Anisina/layout/tags.ejs","hash":"5bf1942a5c575b01e1d8d9e0cb12882e8dfbad00","modified":1521172880914},{"_id":"themes/Anisina/Screenshots/Anisina.png","hash":"146dd991f55a827a514259e20a51de1e9b07a13d","modified":1521163316665},{"_id":"themes/Anisina/layout/_partial/footer.ejs","hash":"6bb9d7fb3cbbb04c5bae38e1237e78cc67427147","modified":1521165180209},{"_id":"themes/Anisina/layout/_partial/head.ejs","hash":"2668476c75ecea9233acb3ad49533d0f2d4ddb3d","modified":1521181606520},{"_id":"themes/Anisina/layout/_partial/pagination.ejs","hash":"557d6bb069a1d48af49ae912994653f44b32a570","modified":1521163316678},{"_id":"themes/Anisina/layout/_partial/nav.ejs","hash":"9b6cdb16e779f71d8e4f02b96e8f88f13934ad36","modified":1521163316678},{"_id":"themes/Anisina/source/css/syntax.styl","hash":"f3f9ff0d1ebc4f7fa18d7e367b2ba2f0899adbd4","modified":1521163316680},{"_id":"themes/Anisina/source/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1521163316680},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1521163316681},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1521163316681},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1521163316682},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1521163316682},{"_id":"themes/Anisina/source/images/header.jpg","hash":"452124ac547b684b0c886b517c18c808ddf05818","modified":1521163316684},{"_id":"themes/Anisina/source/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1521163316697},{"_id":"themes/Anisina/source/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1521163316697},{"_id":"themes/Anisina/source/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1521163316699},{"_id":"themes/Anisina/source/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1521163316699},{"_id":"themes/Anisina/Screenshots/poetry-show.png","hash":"f5fdcd25026a87a0aafeebb1f19cdb3c0a81a666","modified":1521163316676},{"_id":"themes/Anisina/source/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1521163316680},{"_id":"themes/Anisina/source/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1521163316681},{"_id":"themes/Anisina/source/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521163316699},{"_id":"themes/Anisina/Screenshots/mobile-post.jpeg","hash":"2081cdff23a9a8c185a48d9aabcc9dc8e77833ec","modified":1521163316668},{"_id":"themes/Anisina/source/images/earth.jpg","hash":"21f51e6789c1e74865c3f32491c0a4bbc68ba32c","modified":1521163316684},{"_id":"themes/Anisina/source/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1521163316698},{"_id":"themes/Anisina/source/images/blog-bg-black-run.jpg","hash":"41c9134f52d4c4407025a4495c22792afc7e6151","modified":1521163316682},{"_id":"themes/Anisina/Screenshots/pc-index.png","hash":"b04094dac75cb656b4244c1dfaf246168a0f8926","modified":1521163316671},{"_id":"themes/Anisina/Screenshots/pc-post.png","hash":"cde56c0797b6ff8dd555fb1f8c3f9b21bceaa3be","modified":1521163316675},{"_id":"themes/Anisina/source/images/post_default_one.png","hash":"9901f8a82cbbad4c8957442c6e449cb16b799f91","modified":1521163316694},{"_id":"themes/Anisina/source/images/post_default.jpg","hash":"9c563c2e7329d16c7ab6ed9a1fbbc484d18440f1","modified":1521163316691},{"_id":"themes/Anisina/source/images/post_default_two.png","hash":"6be188c90bfdc48bc56ac6d3ddfda24dc1b55b82","modified":1521163316697},{"_id":"public/baidusitemap.xml","hash":"e9f712fb031fc911dc95f6ba772a0378a78abc1b","modified":1521181616879},{"_id":"public/atom.xml","hash":"13cbc544088f7918c4b61b825e21fd9e11ea6f2f","modified":1521181617024},{"_id":"public/content.json","hash":"efe9bb093a043a899b9c381148ebf6002de1dbf6","modified":1521181617032},{"_id":"public/sitemap.xml","hash":"487fcba95b49f64c17dfd255c20994e967867422","modified":1521181617032},{"_id":"public/tags/index.html","hash":"e1f78e17e155b5ceae54984c9f6f489a9ab045fa","modified":1521181617036},{"_id":"public/archives/index.html","hash":"0da4944f1fb5b302b3f75e49a8fd09fce81f12fd","modified":1521181617036},{"_id":"public/archives/2017/index.html","hash":"47dd0b31373e17422f56d03e93ef146c991f51b3","modified":1521181617036},{"_id":"public/archives/2017/11/index.html","hash":"43ce151828555fa577fe3465a01682406d2cb959","modified":1521181617037},{"_id":"public/archives/2018/index.html","hash":"4a619740c8ef9675316d520b40df3e99232324a1","modified":1521181617037},{"_id":"public/archives/2018/03/index.html","hash":"bcb3df265becc53b40af0cd71ad3a68a25427314","modified":1521181617037},{"_id":"public/tags/软件设计师/index.html","hash":"cc50a74387f5399fd2a3b4b2bc1d1b9766036557","modified":1521181617037},{"_id":"public/tags/git/index.html","hash":"dd2ebdd2122bdb7dcb23bea87f932ef7d0daeffa","modified":1521181617037},{"_id":"public/tags/Python/index.html","hash":"dd0ea0572a0675140873d9fcde7869b8363386bc","modified":1521181617037},{"_id":"public/2018/03/16/软件设计师考点内容-三/index.html","hash":"24361fb67af2cec879e23fcd065ebc18a2adc3f7","modified":1521181617037},{"_id":"public/2018/03/16/软件设计师考点内容-二/index.html","hash":"8b095b506ad569c0af2b7f199793297164680456","modified":1521181617037},{"_id":"public/2017/11/04/软件设计师考点内容-一/index.html","hash":"dc9adc51aa7fd7188d30f1ef080e865848bcb61b","modified":1521181617037},{"_id":"public/2017/11/04/git-pull冲突解决/index.html","hash":"0af48ce301b96fd08ec219cfe92fe500d077d1c8","modified":1521181617037},{"_id":"public/2017/11/04/Python批量生成二维码/index.html","hash":"8bb5ffc1565c997d4a2d1bb112f06f7ecac48ce1","modified":1521181617037},{"_id":"public/index.html","hash":"673834c38fece2ec6f733ef012e7c92b2057e03e","modified":1521181617037},{"_id":"public/fonts/glyphicons-halflings-regular.eot","hash":"86b6f62b7853e67d3e635f6512a5a5efc58ea3c3","modified":1521181617041},{"_id":"public/fonts/glyphicons-halflings-regular.ttf","hash":"44bc1850f570972267b169ae18f1cb06b611ffa2","modified":1521181617041},{"_id":"public/fonts/glyphicons-halflings-regular.woff","hash":"278e49a86e634da6f2a02f3b47dd9d2a8f26210f","modified":1521181617042},{"_id":"public/fonts/glyphicons-halflings-regular.woff2","hash":"ca35b697d99cae4d1b60f2d60fcd37771987eb07","modified":1521181617043},{"_id":"public/images/header.jpg","hash":"452124ac547b684b0c886b517c18c808ddf05818","modified":1521181617043},{"_id":"public/fonts/glyphicons-halflings-regular.svg","hash":"de51a8494180a6db074af2dee2383f0a363c5b08","modified":1521181617245},{"_id":"public/css/syntax.css","hash":"4616879fec214c9cc4f5835615348f0bbeabf2a9","modified":1521181617252},{"_id":"public/js/blog.js","hash":"0f805c744ef8a48c0abdd9d204cfc19ee6cafc14","modified":1521181617252},{"_id":"public/js/totop.js","hash":"11ede60fccb7c763d6973f80efc78b47c0843746","modified":1521181617252},{"_id":"public/js/jquery.tagcloud.js","hash":"4e5fd0b07f3bd935f2e603710447e039e3677211","modified":1521181617252},{"_id":"public/css/blog-style.css","hash":"c6830e31138e412c2aa05228c4cd6035063fe651","modified":1521181617252},{"_id":"public/js/bootstrap.min.js","hash":"b3f2ef9f985e7906c9360756b73cd64bf7733647","modified":1521181617252},{"_id":"public/css/bootstrap.min.css","hash":"c5db932e115ff97af7b4512b947cde3ba2964db8","modified":1521181617253},{"_id":"public/js/jquery.min.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1521181617253},{"_id":"public/js/jquery.js","hash":"1852661bd11a09ca9b9cb63d1aa6ff390fffaf4e","modified":1521181617253},{"_id":"public/images/earth.jpg","hash":"21f51e6789c1e74865c3f32491c0a4bbc68ba32c","modified":1521181617255},{"_id":"public/images/blog-bg-black-run.jpg","hash":"41c9134f52d4c4407025a4495c22792afc7e6151","modified":1521181617257},{"_id":"public/images/post_default_one.png","hash":"9901f8a82cbbad4c8957442c6e449cb16b799f91","modified":1521181617297},{"_id":"public/images/post_default.jpg","hash":"9c563c2e7329d16c7ab6ed9a1fbbc484d18440f1","modified":1521181617303},{"_id":"public/images/post_default_two.png","hash":"6be188c90bfdc48bc56ac6d3ddfda24dc1b55b82","modified":1521181617306}],"Category":[],"Data":[],"Page":[{"title":"标签","date":"2017-11-03T07:10:56.000Z","updated":"2017-11-03T07:10:56.000Z","layout":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2017-11-03 15:10:56\nupdated: 2017-11-03 15:10:56\nlayout: tags\ncomments: false\n---\n","path":"tags/index.html","_id":"cjetk9bbc0001o5fycmun9ci4","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"归档","date":"2017-11-03T07:09:55.000Z","updated":"2017-11-03T07:09:55.000Z","layout":"archives","comments":0,"_content":"","source":"archives/index.md","raw":"---\ntitle: 归档\ndate: 2017-11-03 15:09:55\nupdated: 2017-11-03 15:09:55\nlayout: archives\ncomments: false\n---\n","path":"archives/index.html","_id":"cjetk9bbh0003o5fy5oruv45t","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"软件设计师考点内容(一)","date":"2017-11-04T06:54:31.000Z","author":"chenJF","archives":"软考","_content":"\n# 软件设计师考点内容分析\n\n\n### 1、CPU构成\n*     程序计数器(PC)：存放执行指令的地方，计算之前要用到\n*  累加器(AC)：暂时存放算数逻辑运算部件ALU运算的结果信息\n*  指令寄存器(IR)：保存当前正在执行的一条指令\n*  地址寄存器(AR)：保存当前CPU所要访问的内存单元的地址\n\n### 2、DMA(Direct Memory Access，直接内存存取)\n* DMA工作方式，是在DMA控制硬件的控制下，实现内存与外设间数据的直接传送，并不需要CPU参与工作，由于DMA方式是在DMA控制硬件的控制下实现数据的传送，不需要CPU执行程序，故这种方式传送的速度最快。\n\n### 3、系统可靠度\n* 并联部件的可靠度=1-部件失效率的乘积\n\n### 4、海明码\n* 海明码是一种可以纠正一位差错的编码\n* 公式：2<sup>r</sup>>=k+r+1 (r增加的冗余位，k有效的信息位)\n\n### 5、高速缓存Cache\n* Cache位于CPU和主存之间，由硬件实现，容量小，一般在几KB到几MB之间，速度一般比主存快5到10倍，由快速半导体存储器制成，其内容是主存内容的副本(Cache无法扩大主存的容量)，Cache既可存放程序又可存放数据。\n\n### 6、软件分析到设计的过程\n* 研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口\n* 根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型\n* 由数据流图推导出系统的初始结构图\n* 利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止\n* 根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计和数据文件的设计\n* 在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。\n\n### 7、螺旋模型\n* 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级软件应用。\n\n### 8、多态\n* 多态是同一操作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。\n\n### 9、装饰模式、外观模式\n* 装饰模式是一种对象结构型模式，可动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。通过装饰模式，可以在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当需要动态的给一个对象增加功能，这些功能可以再动态的被撤销时可使用装饰模式；当不能采用生成子类的方法进行扩充时也可使用装饰模式。\n* 外观模式是对象的结构模式，要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n### 10、共享锁和排它锁\n* 共享锁(S锁)，又称为读锁，若事务T对数据对象A加上S锁，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上面的S锁。\n* 排它锁(X锁)，又称为写锁，若事务T对数据对象A加上X锁，其他事务不能再对A加任何锁，直到T释放A上的锁。\n\n### 11、二叉树遍历\n* 先序遍历：先根后左子树再右子树\n* 中序遍历：先左子树后根再右子树\n* 后序遍历：先左子树后右子树再根\n\n### 12、算法设计策略\n* 贪心法：求解问题最优解，将问题分解为若干步，每一步都取当前最优解，即局部最优解。\n* 分治法：求解问题唯一解，将问题分解为小规模的子问题，子问题之间相互独立。\n* 回溯法：求解问题最优解或唯一解，就是深度优先搜索，常用递归实现。\n* 分支限界法：求解问题最优解或唯一解，活结点。\n* 动态规划：求解最优解。同分治法类似，只是动态规划保存了之前求得的所有子问题的解，以避免重复的计算。\n* 随机化算法：分类有\n* ①数值随机算法：用于数值问题的求解，得到近似解。\n* ②蒙特卡洛算法：计算数学中的一种计算方法，用于求问题的准确解，得到正确的概率以来与时间。\n* ③拉斯维加斯算法：与蒙特卡洛算法相似，但是绝不返回错误的解。\n* ④舍伍德算法：在确定性算法中加入随机性来降低最坏情况出现的概率。\n\n### 13、域名查询记录\n* 域名查询记录先本地DNS缓存，再HOSTS表，然后再查找本地DNS服务器，顶级域名服务器、权限域名服务器。\n\n### 14、TCP/IP协议栈中协议和层次对应的关系\n![tcp.png](http://upload-images.jianshu.io/upload_images/4970496-279f07818917a8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 15、小根堆和大根堆\n* 小根堆满足关系：k<sub>i</sub> ≤ k<sub>2i</sub> 且 k<sub>i</sub> ≤ k<sub>2i+1</sub>（I=1,2,....,n/2）\n* 大根堆满足关系：k<sub>i</sub> ≥ k<sub>2i</sub> 且 k<sub>i</sub> ≥ k<sub>2i+1</sub>（I=1,2,....,n/2）\n\n","source":"_posts/软件设计师考点内容-一.md","raw":"---\ntitle: 软件设计师考点内容(一)\ndate: 2017-11-04 14:54:31\nauthor: \"chenJF\"\ntags: 软件设计师\narchives: 软考\n---\n\n# 软件设计师考点内容分析\n\n\n### 1、CPU构成\n*     程序计数器(PC)：存放执行指令的地方，计算之前要用到\n*  累加器(AC)：暂时存放算数逻辑运算部件ALU运算的结果信息\n*  指令寄存器(IR)：保存当前正在执行的一条指令\n*  地址寄存器(AR)：保存当前CPU所要访问的内存单元的地址\n\n### 2、DMA(Direct Memory Access，直接内存存取)\n* DMA工作方式，是在DMA控制硬件的控制下，实现内存与外设间数据的直接传送，并不需要CPU参与工作，由于DMA方式是在DMA控制硬件的控制下实现数据的传送，不需要CPU执行程序，故这种方式传送的速度最快。\n\n### 3、系统可靠度\n* 并联部件的可靠度=1-部件失效率的乘积\n\n### 4、海明码\n* 海明码是一种可以纠正一位差错的编码\n* 公式：2<sup>r</sup>>=k+r+1 (r增加的冗余位，k有效的信息位)\n\n### 5、高速缓存Cache\n* Cache位于CPU和主存之间，由硬件实现，容量小，一般在几KB到几MB之间，速度一般比主存快5到10倍，由快速半导体存储器制成，其内容是主存内容的副本(Cache无法扩大主存的容量)，Cache既可存放程序又可存放数据。\n\n### 6、软件分析到设计的过程\n* 研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口\n* 根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型\n* 由数据流图推导出系统的初始结构图\n* 利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止\n* 根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计和数据文件的设计\n* 在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。\n\n### 7、螺旋模型\n* 螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级软件应用。\n\n### 8、多态\n* 多态是同一操作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。\n\n### 9、装饰模式、外观模式\n* 装饰模式是一种对象结构型模式，可动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。通过装饰模式，可以在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当需要动态的给一个对象增加功能，这些功能可以再动态的被撤销时可使用装饰模式；当不能采用生成子类的方法进行扩充时也可使用装饰模式。\n* 外观模式是对象的结构模式，要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。\n\n### 10、共享锁和排它锁\n* 共享锁(S锁)，又称为读锁，若事务T对数据对象A加上S锁，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上面的S锁。\n* 排它锁(X锁)，又称为写锁，若事务T对数据对象A加上X锁，其他事务不能再对A加任何锁，直到T释放A上的锁。\n\n### 11、二叉树遍历\n* 先序遍历：先根后左子树再右子树\n* 中序遍历：先左子树后根再右子树\n* 后序遍历：先左子树后右子树再根\n\n### 12、算法设计策略\n* 贪心法：求解问题最优解，将问题分解为若干步，每一步都取当前最优解，即局部最优解。\n* 分治法：求解问题唯一解，将问题分解为小规模的子问题，子问题之间相互独立。\n* 回溯法：求解问题最优解或唯一解，就是深度优先搜索，常用递归实现。\n* 分支限界法：求解问题最优解或唯一解，活结点。\n* 动态规划：求解最优解。同分治法类似，只是动态规划保存了之前求得的所有子问题的解，以避免重复的计算。\n* 随机化算法：分类有\n* ①数值随机算法：用于数值问题的求解，得到近似解。\n* ②蒙特卡洛算法：计算数学中的一种计算方法，用于求问题的准确解，得到正确的概率以来与时间。\n* ③拉斯维加斯算法：与蒙特卡洛算法相似，但是绝不返回错误的解。\n* ④舍伍德算法：在确定性算法中加入随机性来降低最坏情况出现的概率。\n\n### 13、域名查询记录\n* 域名查询记录先本地DNS缓存，再HOSTS表，然后再查找本地DNS服务器，顶级域名服务器、权限域名服务器。\n\n### 14、TCP/IP协议栈中协议和层次对应的关系\n![tcp.png](http://upload-images.jianshu.io/upload_images/4970496-279f07818917a8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n### 15、小根堆和大根堆\n* 小根堆满足关系：k<sub>i</sub> ≤ k<sub>2i</sub> 且 k<sub>i</sub> ≤ k<sub>2i+1</sub>（I=1,2,....,n/2）\n* 大根堆满足关系：k<sub>i</sub> ≥ k<sub>2i</sub> 且 k<sub>i</sub> ≥ k<sub>2i+1</sub>（I=1,2,....,n/2）\n\n","slug":"软件设计师考点内容-一","published":1,"updated":"2018-03-16T01:21:56.664Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjetk9bb70000o5fynie56d8z","content":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1、CPU构成\"><a href=\"#1、CPU构成\" class=\"headerlink\" title=\"1、CPU构成\"></a>1、CPU构成</h3><ul>\n<li>程序计数器(PC)：存放执行指令的地方，计算之前要用到</li>\n<li>累加器(AC)：暂时存放算数逻辑运算部件ALU运算的结果信息</li>\n<li>指令寄存器(IR)：保存当前正在执行的一条指令</li>\n<li>地址寄存器(AR)：保存当前CPU所要访问的内存单元的地址</li>\n</ul>\n<h3 id=\"2、DMA-Direct-Memory-Access，直接内存存取\"><a href=\"#2、DMA-Direct-Memory-Access，直接内存存取\" class=\"headerlink\" title=\"2、DMA(Direct Memory Access，直接内存存取)\"></a>2、DMA(Direct Memory Access，直接内存存取)</h3><ul>\n<li>DMA工作方式，是在DMA控制硬件的控制下，实现内存与外设间数据的直接传送，并不需要CPU参与工作，由于DMA方式是在DMA控制硬件的控制下实现数据的传送，不需要CPU执行程序，故这种方式传送的速度最快。</li>\n</ul>\n<h3 id=\"3、系统可靠度\"><a href=\"#3、系统可靠度\" class=\"headerlink\" title=\"3、系统可靠度\"></a>3、系统可靠度</h3><ul>\n<li>并联部件的可靠度=1-部件失效率的乘积</li>\n</ul>\n<h3 id=\"4、海明码\"><a href=\"#4、海明码\" class=\"headerlink\" title=\"4、海明码\"></a>4、海明码</h3><ul>\n<li>海明码是一种可以纠正一位差错的编码</li>\n<li>公式：2<sup>r</sup>&gt;=k+r+1 (r增加的冗余位，k有效的信息位)</li>\n</ul>\n<h3 id=\"5、高速缓存Cache\"><a href=\"#5、高速缓存Cache\" class=\"headerlink\" title=\"5、高速缓存Cache\"></a>5、高速缓存Cache</h3><ul>\n<li>Cache位于CPU和主存之间，由硬件实现，容量小，一般在几KB到几MB之间，速度一般比主存快5到10倍，由快速半导体存储器制成，其内容是主存内容的副本(Cache无法扩大主存的容量)，Cache既可存放程序又可存放数据。</li>\n</ul>\n<h3 id=\"6、软件分析到设计的过程\"><a href=\"#6、软件分析到设计的过程\" class=\"headerlink\" title=\"6、软件分析到设计的过程\"></a>6、软件分析到设计的过程</h3><ul>\n<li>研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口</li>\n<li>根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型</li>\n<li>由数据流图推导出系统的初始结构图</li>\n<li>利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止</li>\n<li>根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计和数据文件的设计</li>\n<li>在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。</li>\n</ul>\n<h3 id=\"7、螺旋模型\"><a href=\"#7、螺旋模型\" class=\"headerlink\" title=\"7、螺旋模型\"></a>7、螺旋模型</h3><ul>\n<li>螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级软件应用。</li>\n</ul>\n<h3 id=\"8、多态\"><a href=\"#8、多态\" class=\"headerlink\" title=\"8、多态\"></a>8、多态</h3><ul>\n<li>多态是同一操作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。</li>\n</ul>\n<h3 id=\"9、装饰模式、外观模式\"><a href=\"#9、装饰模式、外观模式\" class=\"headerlink\" title=\"9、装饰模式、外观模式\"></a>9、装饰模式、外观模式</h3><ul>\n<li>装饰模式是一种对象结构型模式，可动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。通过装饰模式，可以在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当需要动态的给一个对象增加功能，这些功能可以再动态的被撤销时可使用装饰模式；当不能采用生成子类的方法进行扩充时也可使用装饰模式。</li>\n<li>外观模式是对象的结构模式，要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>\n</ul>\n<h3 id=\"10、共享锁和排它锁\"><a href=\"#10、共享锁和排它锁\" class=\"headerlink\" title=\"10、共享锁和排它锁\"></a>10、共享锁和排它锁</h3><ul>\n<li>共享锁(S锁)，又称为读锁，若事务T对数据对象A加上S锁，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上面的S锁。</li>\n<li>排它锁(X锁)，又称为写锁，若事务T对数据对象A加上X锁，其他事务不能再对A加任何锁，直到T释放A上的锁。</li>\n</ul>\n<h3 id=\"11、二叉树遍历\"><a href=\"#11、二叉树遍历\" class=\"headerlink\" title=\"11、二叉树遍历\"></a>11、二叉树遍历</h3><ul>\n<li>先序遍历：先根后左子树再右子树</li>\n<li>中序遍历：先左子树后根再右子树</li>\n<li>后序遍历：先左子树后右子树再根</li>\n</ul>\n<h3 id=\"12、算法设计策略\"><a href=\"#12、算法设计策略\" class=\"headerlink\" title=\"12、算法设计策略\"></a>12、算法设计策略</h3><ul>\n<li>贪心法：求解问题最优解，将问题分解为若干步，每一步都取当前最优解，即局部最优解。</li>\n<li>分治法：求解问题唯一解，将问题分解为小规模的子问题，子问题之间相互独立。</li>\n<li>回溯法：求解问题最优解或唯一解，就是深度优先搜索，常用递归实现。</li>\n<li>分支限界法：求解问题最优解或唯一解，活结点。</li>\n<li>动态规划：求解最优解。同分治法类似，只是动态规划保存了之前求得的所有子问题的解，以避免重复的计算。</li>\n<li>随机化算法：分类有</li>\n<li>①数值随机算法：用于数值问题的求解，得到近似解。</li>\n<li>②蒙特卡洛算法：计算数学中的一种计算方法，用于求问题的准确解，得到正确的概率以来与时间。</li>\n<li>③拉斯维加斯算法：与蒙特卡洛算法相似，但是绝不返回错误的解。</li>\n<li>④舍伍德算法：在确定性算法中加入随机性来降低最坏情况出现的概率。</li>\n</ul>\n<h3 id=\"13、域名查询记录\"><a href=\"#13、域名查询记录\" class=\"headerlink\" title=\"13、域名查询记录\"></a>13、域名查询记录</h3><ul>\n<li>域名查询记录先本地DNS缓存，再HOSTS表，然后再查找本地DNS服务器，顶级域名服务器、权限域名服务器。</li>\n</ul>\n<h3 id=\"14、TCP-IP协议栈中协议和层次对应的关系\"><a href=\"#14、TCP-IP协议栈中协议和层次对应的关系\" class=\"headerlink\" title=\"14、TCP/IP协议栈中协议和层次对应的关系\"></a>14、TCP/IP协议栈中协议和层次对应的关系</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-279f07818917a8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"tcp.png\"></p>\n<h3 id=\"15、小根堆和大根堆\"><a href=\"#15、小根堆和大根堆\" class=\"headerlink\" title=\"15、小根堆和大根堆\"></a>15、小根堆和大根堆</h3><ul>\n<li>小根堆满足关系：k<sub>i</sub> ≤ k<sub>2i</sub> 且 k<sub>i</sub> ≤ k<sub>2i+1</sub>（I=1,2,….,n/2）</li>\n<li>大根堆满足关系：k<sub>i</sub> ≥ k<sub>2i</sub> 且 k<sub>i</sub> ≥ k<sub>2i+1</sub>（I=1,2,….,n/2）</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1、CPU构成\"><a href=\"#1、CPU构成\" class=\"headerlink\" title=\"1、CPU构成\"></a>1、CPU构成</h3><ul>\n<li>程序计数器(PC)：存放执行指令的地方，计算之前要用到</li>\n<li>累加器(AC)：暂时存放算数逻辑运算部件ALU运算的结果信息</li>\n<li>指令寄存器(IR)：保存当前正在执行的一条指令</li>\n<li>地址寄存器(AR)：保存当前CPU所要访问的内存单元的地址</li>\n</ul>\n<h3 id=\"2、DMA-Direct-Memory-Access，直接内存存取\"><a href=\"#2、DMA-Direct-Memory-Access，直接内存存取\" class=\"headerlink\" title=\"2、DMA(Direct Memory Access，直接内存存取)\"></a>2、DMA(Direct Memory Access，直接内存存取)</h3><ul>\n<li>DMA工作方式，是在DMA控制硬件的控制下，实现内存与外设间数据的直接传送，并不需要CPU参与工作，由于DMA方式是在DMA控制硬件的控制下实现数据的传送，不需要CPU执行程序，故这种方式传送的速度最快。</li>\n</ul>\n<h3 id=\"3、系统可靠度\"><a href=\"#3、系统可靠度\" class=\"headerlink\" title=\"3、系统可靠度\"></a>3、系统可靠度</h3><ul>\n<li>并联部件的可靠度=1-部件失效率的乘积</li>\n</ul>\n<h3 id=\"4、海明码\"><a href=\"#4、海明码\" class=\"headerlink\" title=\"4、海明码\"></a>4、海明码</h3><ul>\n<li>海明码是一种可以纠正一位差错的编码</li>\n<li>公式：2<sup>r</sup>&gt;=k+r+1 (r增加的冗余位，k有效的信息位)</li>\n</ul>\n<h3 id=\"5、高速缓存Cache\"><a href=\"#5、高速缓存Cache\" class=\"headerlink\" title=\"5、高速缓存Cache\"></a>5、高速缓存Cache</h3><ul>\n<li>Cache位于CPU和主存之间，由硬件实现，容量小，一般在几KB到几MB之间，速度一般比主存快5到10倍，由快速半导体存储器制成，其内容是主存内容的副本(Cache无法扩大主存的容量)，Cache既可存放程序又可存放数据。</li>\n</ul>\n<h3 id=\"6、软件分析到设计的过程\"><a href=\"#6、软件分析到设计的过程\" class=\"headerlink\" title=\"6、软件分析到设计的过程\"></a>6、软件分析到设计的过程</h3><ul>\n<li>研究、分析和审查数据流图。根据穿越系统边界的信息流初步确定系统与外部接口</li>\n<li>根据数据流图决定问题的类型。数据处理问题通常有两种类型：变换型和事务型</li>\n<li>由数据流图推导出系统的初始结构图</li>\n<li>利用一些启发式原则来改进系统的初始结构图，直到得到符合要求的结构图为止</li>\n<li>根据分析模型中的实体关系图和数据字典进行数据设计，包括数据库设计和数据文件的设计</li>\n<li>在设计的基础上，依旧分析模型中的加工规格说明、状态转换图进行过程设计。</li>\n</ul>\n<h3 id=\"7、螺旋模型\"><a href=\"#7、螺旋模型\" class=\"headerlink\" title=\"7、螺旋模型\"></a>7、螺旋模型</h3><ul>\n<li>螺旋模型是一种演化软件开发过程模型，它兼顾了快速原型的迭代的特征以及瀑布模型的系统化与严格监控。螺旋模型最大的特点在于引入了其他模型不具备的风险分析，使软件在无法排除重大风险时有机会停止，以减小损失。同时，在每个迭代阶段构建原型是螺旋模型用以减小风险的途径。螺旋模型更适合大型的昂贵的系统级软件应用。</li>\n</ul>\n<h3 id=\"8、多态\"><a href=\"#8、多态\" class=\"headerlink\" title=\"8、多态\"></a>8、多态</h3><ul>\n<li>多态是同一操作用于不同对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。也就是说客户类其实在调用方法时，并不需要知道特定子类的实现，都会用统一的方式来调用。</li>\n</ul>\n<h3 id=\"9、装饰模式、外观模式\"><a href=\"#9、装饰模式、外观模式\" class=\"headerlink\" title=\"9、装饰模式、外观模式\"></a>9、装饰模式、外观模式</h3><ul>\n<li>装饰模式是一种对象结构型模式，可动态的给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。通过装饰模式，可以在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当需要动态的给一个对象增加功能，这些功能可以再动态的被撤销时可使用装饰模式；当不能采用生成子类的方法进行扩充时也可使用装饰模式。</li>\n<li>外观模式是对象的结构模式，要求外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</li>\n</ul>\n<h3 id=\"10、共享锁和排它锁\"><a href=\"#10、共享锁和排它锁\" class=\"headerlink\" title=\"10、共享锁和排它锁\"></a>10、共享锁和排它锁</h3><ul>\n<li>共享锁(S锁)，又称为读锁，若事务T对数据对象A加上S锁，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上面的S锁。</li>\n<li>排它锁(X锁)，又称为写锁，若事务T对数据对象A加上X锁，其他事务不能再对A加任何锁，直到T释放A上的锁。</li>\n</ul>\n<h3 id=\"11、二叉树遍历\"><a href=\"#11、二叉树遍历\" class=\"headerlink\" title=\"11、二叉树遍历\"></a>11、二叉树遍历</h3><ul>\n<li>先序遍历：先根后左子树再右子树</li>\n<li>中序遍历：先左子树后根再右子树</li>\n<li>后序遍历：先左子树后右子树再根</li>\n</ul>\n<h3 id=\"12、算法设计策略\"><a href=\"#12、算法设计策略\" class=\"headerlink\" title=\"12、算法设计策略\"></a>12、算法设计策略</h3><ul>\n<li>贪心法：求解问题最优解，将问题分解为若干步，每一步都取当前最优解，即局部最优解。</li>\n<li>分治法：求解问题唯一解，将问题分解为小规模的子问题，子问题之间相互独立。</li>\n<li>回溯法：求解问题最优解或唯一解，就是深度优先搜索，常用递归实现。</li>\n<li>分支限界法：求解问题最优解或唯一解，活结点。</li>\n<li>动态规划：求解最优解。同分治法类似，只是动态规划保存了之前求得的所有子问题的解，以避免重复的计算。</li>\n<li>随机化算法：分类有</li>\n<li>①数值随机算法：用于数值问题的求解，得到近似解。</li>\n<li>②蒙特卡洛算法：计算数学中的一种计算方法，用于求问题的准确解，得到正确的概率以来与时间。</li>\n<li>③拉斯维加斯算法：与蒙特卡洛算法相似，但是绝不返回错误的解。</li>\n<li>④舍伍德算法：在确定性算法中加入随机性来降低最坏情况出现的概率。</li>\n</ul>\n<h3 id=\"13、域名查询记录\"><a href=\"#13、域名查询记录\" class=\"headerlink\" title=\"13、域名查询记录\"></a>13、域名查询记录</h3><ul>\n<li>域名查询记录先本地DNS缓存，再HOSTS表，然后再查找本地DNS服务器，顶级域名服务器、权限域名服务器。</li>\n</ul>\n<h3 id=\"14、TCP-IP协议栈中协议和层次对应的关系\"><a href=\"#14、TCP-IP协议栈中协议和层次对应的关系\" class=\"headerlink\" title=\"14、TCP/IP协议栈中协议和层次对应的关系\"></a>14、TCP/IP协议栈中协议和层次对应的关系</h3><p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-279f07818917a8b1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"tcp.png\"></p>\n<h3 id=\"15、小根堆和大根堆\"><a href=\"#15、小根堆和大根堆\" class=\"headerlink\" title=\"15、小根堆和大根堆\"></a>15、小根堆和大根堆</h3><ul>\n<li>小根堆满足关系：k<sub>i</sub> ≤ k<sub>2i</sub> 且 k<sub>i</sub> ≤ k<sub>2i+1</sub>（I=1,2,….,n/2）</li>\n<li>大根堆满足关系：k<sub>i</sub> ≥ k<sub>2i</sub> 且 k<sub>i</sub> ≥ k<sub>2i+1</sub>（I=1,2,….,n/2）</li>\n</ul>\n"},{"title":"软件设计师考点内容(三)","date":"2018-03-16T03:20:00.000Z","author":"chenJF","archives":"软考","_content":"\n# 软件设计师考点内容分析\n\n### 1.VLIW\n* VLIW（Very Long Instruction Word），超长指令字。一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度。\n\n### 2.编译程序、解释程序\n* 编译程序：编译程序的功能是把用高级语言书写的源程序翻译成与之等价的目标程序。编译过程划分为词法分析、语法分析、语义分析、中间代码生成（三种表达形式：语法树、后缀式、三地址代码）、代码优化和目标代码生成6个阶段。目标程序可以独立于源程序运行。\n* 解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在允许用户程序时，它是直接执行源程序或源程序的内部形式（中间代码）。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。\n\n### 3.脚本语言\n* 脚本语言（Script languages，scripting programming languages，scripting languages）是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。此命名起源于一个脚本“screenplay”；每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批处理语言或者工作控制语言。一个脚本通常是解释运行而非编译。\n\n### 4.仓库风格\n#### 优点：\n* ①.解决问题的多方法性\n* ②.具有可更改性和可维护性\n* ③.有可重用的知识源\n* ④.支持容错性和健壮性\n\n#### 缺点：\n* ①.测试困难：由于黑板模式的系统中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试。\n* ②.不能保证有好的求解方法\n* ③.效率低\n* ④.开发成本高\n* ⑤.缺少对并行机的支持\n\n#### 风格：\n* ①.数据库系统\n* ②.黑板系统\n* ③.超文本系统\n\n### 5.测试策略\n#### ①.自顶向下\n* 方法：从主控模块开始，沿着程序控制层次向下移动，逐渐把各模块组合起来。（深度优先或广度优先）\n* 优点：可以在早期实现软件的一个完整功能。\n* 缺点：没有底层返回来真实数据流。\n\n#### ②.自底向上\n* 方法：从软件结构最底层的模块开始组装和测试，不需要桩模块。\n* 优点：可以并行集成，对被测模块可测性要求比自顶向下集成策略低。\n* 缺点：驱动模块开发量大，整体设计的错误发现较晚，集成到顶层时将变得越来越复杂。\n\n#### ③.三明治\n* 方法：混合增量式测试策略，综合了自顶向下和自底向上两种集成方法。\n* 优点：桩模块和驱动模块的开发工作都比较小。\n* 缺点：增加了缺陷的定位难度，目标层在集成前测试不充分。\n\n\n\n\n","source":"_posts/软件设计师考点内容-三.md","raw":"---\ntitle: 软件设计师考点内容(三)\ndate: 2018-03-16 11:20:00\nauthor: \"chenJF\"\ntags: 软件设计师\narchives: 软考\n---\n\n# 软件设计师考点内容分析\n\n### 1.VLIW\n* VLIW（Very Long Instruction Word），超长指令字。一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度。\n\n### 2.编译程序、解释程序\n* 编译程序：编译程序的功能是把用高级语言书写的源程序翻译成与之等价的目标程序。编译过程划分为词法分析、语法分析、语义分析、中间代码生成（三种表达形式：语法树、后缀式、三地址代码）、代码优化和目标代码生成6个阶段。目标程序可以独立于源程序运行。\n* 解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在允许用户程序时，它是直接执行源程序或源程序的内部形式（中间代码）。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。\n\n### 3.脚本语言\n* 脚本语言（Script languages，scripting programming languages，scripting languages）是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。此命名起源于一个脚本“screenplay”；每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批处理语言或者工作控制语言。一个脚本通常是解释运行而非编译。\n\n### 4.仓库风格\n#### 优点：\n* ①.解决问题的多方法性\n* ②.具有可更改性和可维护性\n* ③.有可重用的知识源\n* ④.支持容错性和健壮性\n\n#### 缺点：\n* ①.测试困难：由于黑板模式的系统中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试。\n* ②.不能保证有好的求解方法\n* ③.效率低\n* ④.开发成本高\n* ⑤.缺少对并行机的支持\n\n#### 风格：\n* ①.数据库系统\n* ②.黑板系统\n* ③.超文本系统\n\n### 5.测试策略\n#### ①.自顶向下\n* 方法：从主控模块开始，沿着程序控制层次向下移动，逐渐把各模块组合起来。（深度优先或广度优先）\n* 优点：可以在早期实现软件的一个完整功能。\n* 缺点：没有底层返回来真实数据流。\n\n#### ②.自底向上\n* 方法：从软件结构最底层的模块开始组装和测试，不需要桩模块。\n* 优点：可以并行集成，对被测模块可测性要求比自顶向下集成策略低。\n* 缺点：驱动模块开发量大，整体设计的错误发现较晚，集成到顶层时将变得越来越复杂。\n\n#### ③.三明治\n* 方法：混合增量式测试策略，综合了自顶向下和自底向上两种集成方法。\n* 优点：桩模块和驱动模块的开发工作都比较小。\n* 缺点：增加了缺陷的定位难度，目标层在集成前测试不充分。\n\n\n\n\n","slug":"软件设计师考点内容-三","published":1,"updated":"2018-03-16T03:41:40.231Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjetk9bbe0002o5fy505acw83","content":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1-VLIW\"><a href=\"#1-VLIW\" class=\"headerlink\" title=\"1.VLIW\"></a>1.VLIW</h3><ul>\n<li>VLIW（Very Long Instruction Word），超长指令字。一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度。</li>\n</ul>\n<h3 id=\"2-编译程序、解释程序\"><a href=\"#2-编译程序、解释程序\" class=\"headerlink\" title=\"2.编译程序、解释程序\"></a>2.编译程序、解释程序</h3><ul>\n<li>编译程序：编译程序的功能是把用高级语言书写的源程序翻译成与之等价的目标程序。编译过程划分为词法分析、语法分析、语义分析、中间代码生成（三种表达形式：语法树、后缀式、三地址代码）、代码优化和目标代码生成6个阶段。目标程序可以独立于源程序运行。</li>\n<li>解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在允许用户程序时，它是直接执行源程序或源程序的内部形式（中间代码）。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。</li>\n</ul>\n<h3 id=\"3-脚本语言\"><a href=\"#3-脚本语言\" class=\"headerlink\" title=\"3.脚本语言\"></a>3.脚本语言</h3><ul>\n<li>脚本语言（Script languages，scripting programming languages，scripting languages）是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。此命名起源于一个脚本“screenplay”；每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批处理语言或者工作控制语言。一个脚本通常是解释运行而非编译。</li>\n</ul>\n<h3 id=\"4-仓库风格\"><a href=\"#4-仓库风格\" class=\"headerlink\" title=\"4.仓库风格\"></a>4.仓库风格</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>①.解决问题的多方法性</li>\n<li>②.具有可更改性和可维护性</li>\n<li>③.有可重用的知识源</li>\n<li>④.支持容错性和健壮性</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>①.测试困难：由于黑板模式的系统中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试。</li>\n<li>②.不能保证有好的求解方法</li>\n<li>③.效率低</li>\n<li>④.开发成本高</li>\n<li>⑤.缺少对并行机的支持</li>\n</ul>\n<h4 id=\"风格：\"><a href=\"#风格：\" class=\"headerlink\" title=\"风格：\"></a>风格：</h4><ul>\n<li>①.数据库系统</li>\n<li>②.黑板系统</li>\n<li>③.超文本系统</li>\n</ul>\n<h3 id=\"5-测试策略\"><a href=\"#5-测试策略\" class=\"headerlink\" title=\"5.测试策略\"></a>5.测试策略</h3><h4 id=\"①-自顶向下\"><a href=\"#①-自顶向下\" class=\"headerlink\" title=\"①.自顶向下\"></a>①.自顶向下</h4><ul>\n<li>方法：从主控模块开始，沿着程序控制层次向下移动，逐渐把各模块组合起来。（深度优先或广度优先）</li>\n<li>优点：可以在早期实现软件的一个完整功能。</li>\n<li>缺点：没有底层返回来真实数据流。</li>\n</ul>\n<h4 id=\"②-自底向上\"><a href=\"#②-自底向上\" class=\"headerlink\" title=\"②.自底向上\"></a>②.自底向上</h4><ul>\n<li>方法：从软件结构最底层的模块开始组装和测试，不需要桩模块。</li>\n<li>优点：可以并行集成，对被测模块可测性要求比自顶向下集成策略低。</li>\n<li>缺点：驱动模块开发量大，整体设计的错误发现较晚，集成到顶层时将变得越来越复杂。</li>\n</ul>\n<h4 id=\"③-三明治\"><a href=\"#③-三明治\" class=\"headerlink\" title=\"③.三明治\"></a>③.三明治</h4><ul>\n<li>方法：混合增量式测试策略，综合了自顶向下和自底向上两种集成方法。</li>\n<li>优点：桩模块和驱动模块的开发工作都比较小。</li>\n<li>缺点：增加了缺陷的定位难度，目标层在集成前测试不充分。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1-VLIW\"><a href=\"#1-VLIW\" class=\"headerlink\" title=\"1.VLIW\"></a>1.VLIW</h3><ul>\n<li>VLIW（Very Long Instruction Word），超长指令字。一种非常长的指令组合，它把许多条指令连在一起，增加了运算的速度。</li>\n</ul>\n<h3 id=\"2-编译程序、解释程序\"><a href=\"#2-编译程序、解释程序\" class=\"headerlink\" title=\"2.编译程序、解释程序\"></a>2.编译程序、解释程序</h3><ul>\n<li>编译程序：编译程序的功能是把用高级语言书写的源程序翻译成与之等价的目标程序。编译过程划分为词法分析、语法分析、语义分析、中间代码生成（三种表达形式：语法树、后缀式、三地址代码）、代码优化和目标代码生成6个阶段。目标程序可以独立于源程序运行。</li>\n<li>解释程序：解释程序是一种语言处理程序，在词法、语法和语义分析方面与编译程序的工作原理基本相同，但在允许用户程序时，它是直接执行源程序或源程序的内部形式（中间代码）。因此，解释程序并不产生目标程序，这是它和编译程序的主要区别。</li>\n</ul>\n<h3 id=\"3-脚本语言\"><a href=\"#3-脚本语言\" class=\"headerlink\" title=\"3.脚本语言\"></a>3.脚本语言</h3><ul>\n<li>脚本语言（Script languages，scripting programming languages，scripting languages）是为了缩短传统的编写-编译-链接-运行（edit-compile-link-run）过程而创建的计算机编程语言。此命名起源于一个脚本“screenplay”；每次运行都会使对话框逐字重复。早期的脚本语言经常被称为批处理语言或者工作控制语言。一个脚本通常是解释运行而非编译。</li>\n</ul>\n<h3 id=\"4-仓库风格\"><a href=\"#4-仓库风格\" class=\"headerlink\" title=\"4.仓库风格\"></a>4.仓库风格</h3><h4 id=\"优点：\"><a href=\"#优点：\" class=\"headerlink\" title=\"优点：\"></a>优点：</h4><ul>\n<li>①.解决问题的多方法性</li>\n<li>②.具有可更改性和可维护性</li>\n<li>③.有可重用的知识源</li>\n<li>④.支持容错性和健壮性</li>\n</ul>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ul>\n<li>①.测试困难：由于黑板模式的系统中央数据构件来描述系统的体现系统的状态，所以系统的执行没有确定的顺序，其结果的可再现性比较差，难于测试。</li>\n<li>②.不能保证有好的求解方法</li>\n<li>③.效率低</li>\n<li>④.开发成本高</li>\n<li>⑤.缺少对并行机的支持</li>\n</ul>\n<h4 id=\"风格：\"><a href=\"#风格：\" class=\"headerlink\" title=\"风格：\"></a>风格：</h4><ul>\n<li>①.数据库系统</li>\n<li>②.黑板系统</li>\n<li>③.超文本系统</li>\n</ul>\n<h3 id=\"5-测试策略\"><a href=\"#5-测试策略\" class=\"headerlink\" title=\"5.测试策略\"></a>5.测试策略</h3><h4 id=\"①-自顶向下\"><a href=\"#①-自顶向下\" class=\"headerlink\" title=\"①.自顶向下\"></a>①.自顶向下</h4><ul>\n<li>方法：从主控模块开始，沿着程序控制层次向下移动，逐渐把各模块组合起来。（深度优先或广度优先）</li>\n<li>优点：可以在早期实现软件的一个完整功能。</li>\n<li>缺点：没有底层返回来真实数据流。</li>\n</ul>\n<h4 id=\"②-自底向上\"><a href=\"#②-自底向上\" class=\"headerlink\" title=\"②.自底向上\"></a>②.自底向上</h4><ul>\n<li>方法：从软件结构最底层的模块开始组装和测试，不需要桩模块。</li>\n<li>优点：可以并行集成，对被测模块可测性要求比自顶向下集成策略低。</li>\n<li>缺点：驱动模块开发量大，整体设计的错误发现较晚，集成到顶层时将变得越来越复杂。</li>\n</ul>\n<h4 id=\"③-三明治\"><a href=\"#③-三明治\" class=\"headerlink\" title=\"③.三明治\"></a>③.三明治</h4><ul>\n<li>方法：混合增量式测试策略，综合了自顶向下和自底向上两种集成方法。</li>\n<li>优点：桩模块和驱动模块的开发工作都比较小。</li>\n<li>缺点：增加了缺陷的定位难度，目标层在集成前测试不充分。</li>\n</ul>\n"},{"title":"git pull冲突解决","date":"2017-11-04T07:04:14.000Z","author":"chenJF","archives":"工具","_content":"\n### 导语：\n> 在公司团队中写完代码就要提交到git上面，因为多人合作，先要将远端的代码pull更新到本地。往往这时候因为大家对同一个文件同一个地方做了操作，导致pull代码冲突发生，工程崩溃。提示错误信息如下：\n~~~\nerror: Your local changes to 'c/environ.c' would be overwritten by merge.  Aborting.\nPlease, commit your changes or stash them before you can merge.\n~~~\n> 这个提示意思就是说更新下来的内容和本地修改的内容有冲突，先提交你改变的内容或者先将你本地修改的内容暂时存起来。\n> 下面我们就分几步解决处理这个pull冲突问题.\n\n### 1.存储本地修改的内容\n~~~\ngit stash\n~~~\n这句命令就是将本地修改的代码做一份备份存储起来，可以用git stash list 查看刚刚备份保存的内容：\n![git stash list.png](http://upload-images.jianshu.io/upload_images/4970496-84f5c1a7a77608c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n其中stash@{0}就是刚刚备份存储的标记\n\n### 2.pull内容\n将本地代码做了备份保存后，就可以pull远端代码\n~~~\ngit pull\n~~~\n\n### 3.还原备份暂存的代码\n~~~\ngit stash pop stash@{0}\n~~~\nstash@{0}是你刚刚备份存储的标记\n这时候系统会提示类似以下的信息：\n~~~\nAuto-merging c/environ.c\nCONFLICT (content): Merge conflict in c/environ.c\n~~~\n这个提示内容意思就是系统自动合并修改的内容，但是当中会有冲突，需要解决其中的冲突。\n\n### 4.解决文件中的冲突内容\n打开上面提示的冲突文件，会看到类似的内容：\n\n![冲突提示.png](http://upload-images.jianshu.io/upload_images/4970496-92f347853efe0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n其中Updated upstream和=======之间的内容是从远端pull下来的代码，=======和Stashed changes之间的内容则是你本地修改的内容。这时候，需要你修改决定留下哪些需要的内容。\n\n最后，解决完冲突，就可以正常git提交了。\n","source":"_posts/git-pull冲突解决.md","raw":"---\ntitle: git pull冲突解决\ndate: 2017-11-04 15:04:14\nauthor: \"chenJF\"\ntags: git\narchives: 工具\n---\n\n### 导语：\n> 在公司团队中写完代码就要提交到git上面，因为多人合作，先要将远端的代码pull更新到本地。往往这时候因为大家对同一个文件同一个地方做了操作，导致pull代码冲突发生，工程崩溃。提示错误信息如下：\n~~~\nerror: Your local changes to 'c/environ.c' would be overwritten by merge.  Aborting.\nPlease, commit your changes or stash them before you can merge.\n~~~\n> 这个提示意思就是说更新下来的内容和本地修改的内容有冲突，先提交你改变的内容或者先将你本地修改的内容暂时存起来。\n> 下面我们就分几步解决处理这个pull冲突问题.\n\n### 1.存储本地修改的内容\n~~~\ngit stash\n~~~\n这句命令就是将本地修改的代码做一份备份存储起来，可以用git stash list 查看刚刚备份保存的内容：\n![git stash list.png](http://upload-images.jianshu.io/upload_images/4970496-84f5c1a7a77608c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600)\n其中stash@{0}就是刚刚备份存储的标记\n\n### 2.pull内容\n将本地代码做了备份保存后，就可以pull远端代码\n~~~\ngit pull\n~~~\n\n### 3.还原备份暂存的代码\n~~~\ngit stash pop stash@{0}\n~~~\nstash@{0}是你刚刚备份存储的标记\n这时候系统会提示类似以下的信息：\n~~~\nAuto-merging c/environ.c\nCONFLICT (content): Merge conflict in c/environ.c\n~~~\n这个提示内容意思就是系统自动合并修改的内容，但是当中会有冲突，需要解决其中的冲突。\n\n### 4.解决文件中的冲突内容\n打开上面提示的冲突文件，会看到类似的内容：\n\n![冲突提示.png](http://upload-images.jianshu.io/upload_images/4970496-92f347853efe0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500)\n其中Updated upstream和=======之间的内容是从远端pull下来的代码，=======和Stashed changes之间的内容则是你本地修改的内容。这时候，需要你修改决定留下哪些需要的内容。\n\n最后，解决完冲突，就可以正常git提交了。\n","slug":"git-pull冲突解决","published":1,"updated":"2018-03-16T01:21:56.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjetk9bbm0005o5fyfrs0xo8j","content":"<h3 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h3><blockquote>\n<p>在公司团队中写完代码就要提交到git上面，因为多人合作，先要将远端的代码pull更新到本地。往往这时候因为大家对同一个文件同一个地方做了操作，导致pull代码冲突发生，工程崩溃。提示错误信息如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">error: Your local changes to &apos;c/environ.c&apos; would be overwritten by merge.  Aborting.</div><div class=\"line\">Please, commit your changes or stash them before you can merge.</div></pre></td></tr></table></figure></p>\n<p>这个提示意思就是说更新下来的内容和本地修改的内容有冲突，先提交你改变的内容或者先将你本地修改的内容暂时存起来。<br>下面我们就分几步解决处理这个pull冲突问题.</p>\n</blockquote>\n<h3 id=\"1-存储本地修改的内容\"><a href=\"#1-存储本地修改的内容\" class=\"headerlink\" title=\"1.存储本地修改的内容\"></a>1.存储本地修改的内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git stash</div></pre></td></tr></table></figure>\n<p>这句命令就是将本地修改的代码做一份备份存储起来，可以用git stash list 查看刚刚备份保存的内容：<br><img src=\"http://upload-images.jianshu.io/upload_images/4970496-84f5c1a7a77608c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"git stash list.png\"><br>其中stash@{0}就是刚刚备份存储的标记</p>\n<h3 id=\"2-pull内容\"><a href=\"#2-pull内容\" class=\"headerlink\" title=\"2.pull内容\"></a>2.pull内容</h3><p>将本地代码做了备份保存后，就可以pull远端代码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git pull</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-还原备份暂存的代码\"><a href=\"#3-还原备份暂存的代码\" class=\"headerlink\" title=\"3.还原备份暂存的代码\"></a>3.还原备份暂存的代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git stash pop stash@&#123;0&#125;</div></pre></td></tr></table></figure>\n<p>stash@{0}是你刚刚备份存储的标记<br>这时候系统会提示类似以下的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Auto-merging c/environ.c</div><div class=\"line\">CONFLICT (content): Merge conflict in c/environ.c</div></pre></td></tr></table></figure></p>\n<p>这个提示内容意思就是系统自动合并修改的内容，但是当中会有冲突，需要解决其中的冲突。</p>\n<h3 id=\"4-解决文件中的冲突内容\"><a href=\"#4-解决文件中的冲突内容\" class=\"headerlink\" title=\"4.解决文件中的冲突内容\"></a>4.解决文件中的冲突内容</h3><p>打开上面提示的冲突文件，会看到类似的内容：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-92f347853efe0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"冲突提示.png\"><br>其中Updated upstream和=======之间的内容是从远端pull下来的代码，=======和Stashed changes之间的内容则是你本地修改的内容。这时候，需要你修改决定留下哪些需要的内容。</p>\n<p>最后，解决完冲突，就可以正常git提交了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h3><blockquote>\n<p>在公司团队中写完代码就要提交到git上面，因为多人合作，先要将远端的代码pull更新到本地。往往这时候因为大家对同一个文件同一个地方做了操作，导致pull代码冲突发生，工程崩溃。提示错误信息如下：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">error: Your local changes to &apos;c/environ.c&apos; would be overwritten by merge.  Aborting.</div><div class=\"line\">Please, commit your changes or stash them before you can merge.</div></pre></td></tr></table></figure></p>\n<p>这个提示意思就是说更新下来的内容和本地修改的内容有冲突，先提交你改变的内容或者先将你本地修改的内容暂时存起来。<br>下面我们就分几步解决处理这个pull冲突问题.</p>\n</blockquote>\n<h3 id=\"1-存储本地修改的内容\"><a href=\"#1-存储本地修改的内容\" class=\"headerlink\" title=\"1.存储本地修改的内容\"></a>1.存储本地修改的内容</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git stash</div></pre></td></tr></table></figure>\n<p>这句命令就是将本地修改的代码做一份备份存储起来，可以用git stash list 查看刚刚备份保存的内容：<br><img src=\"http://upload-images.jianshu.io/upload_images/4970496-84f5c1a7a77608c6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/600\" alt=\"git stash list.png\"><br>其中stash@{0}就是刚刚备份存储的标记</p>\n<h3 id=\"2-pull内容\"><a href=\"#2-pull内容\" class=\"headerlink\" title=\"2.pull内容\"></a>2.pull内容</h3><p>将本地代码做了备份保存后，就可以pull远端代码<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git pull</div></pre></td></tr></table></figure></p>\n<h3 id=\"3-还原备份暂存的代码\"><a href=\"#3-还原备份暂存的代码\" class=\"headerlink\" title=\"3.还原备份暂存的代码\"></a>3.还原备份暂存的代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">git stash pop stash@&#123;0&#125;</div></pre></td></tr></table></figure>\n<p>stash@{0}是你刚刚备份存储的标记<br>这时候系统会提示类似以下的信息：<br><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">Auto-merging c/environ.c</div><div class=\"line\">CONFLICT (content): Merge conflict in c/environ.c</div></pre></td></tr></table></figure></p>\n<p>这个提示内容意思就是系统自动合并修改的内容，但是当中会有冲突，需要解决其中的冲突。</p>\n<h3 id=\"4-解决文件中的冲突内容\"><a href=\"#4-解决文件中的冲突内容\" class=\"headerlink\" title=\"4.解决文件中的冲突内容\"></a>4.解决文件中的冲突内容</h3><p>打开上面提示的冲突文件，会看到类似的内容：</p>\n<p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-92f347853efe0765.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/500\" alt=\"冲突提示.png\"><br>其中Updated upstream和=======之间的内容是从远端pull下来的代码，=======和Stashed changes之间的内容则是你本地修改的内容。这时候，需要你修改决定留下哪些需要的内容。</p>\n<p>最后，解决完冲突，就可以正常git提交了。</p>\n"},{"title":"Python批量生成二维码","date":"2017-11-04T06:54:31.000Z","author":"chenJF","archives":"Python","_content":"# Python2.7 批量生成二维\n\n## 导语：\n> 本文针对mac电脑利用Python2.7脚本批量生成二维码，由于Python生成二维码利用了qrcode和image库，需要先用pip安装这两个库。这里顺便说了下pip的安装。\n\n\n### 1.pip的安装\n* 用命令行安装pip\n~~~\nsudo easy_install pip\n~~~\n* 检查是否安装成功，只要不是not found pip，则安装成功\n~~~\npip help\n~~~\n<br>\n### 2.安装qrcode和image库\n* 安装命令\n~~~\n#安装失败可以加sudo安装\npip install qrcode\npip install image\n~~~\n* 检查是否安装成功,安装成功会有相应的版本信息\n~~~\npip show qrcode\npip show image\n~~~\n* 安装成功显示界面信息\n\n* ![python-qrcode.png](http://upload-images.jianshu.io/upload_images/4970496-ce568913bd5e15a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n<br>\n### 3.示例代码\n~~~\n# 导入qrcode库\nimport qrcode\n\n#生成一张二维码图片，url二维码的内容，name保存二维码图片的名字\ndef createOneQR(url,name):\nqr=qrcode.QRCode(version = 2,\nerror_correction = qrcode.constants.ERROR_CORRECT_L, #容错样式\nbox_size=10,   #每个格子的像素\nborder=1)      #边框宽度\nqr.add_data(url)\nqr.make(fit=True)\nimg = qr.make_image()\nimg.resize((140, 140)).save(name)   #保存为140*140的图片\n\n\n#根据文档批量生成二维码\ndef getQR():\nnum = 0\n#遍历文档每行内容生成二维码\nfor line in open(\"license-for-card.txt\"):\nimageName = \"license\"+str(num)+\".png\"\ncreateOneQR(line,imageName)\nnum += 1\n\ngetQR()\n~~~\n\n* 参数 version 表示生成二维码的尺寸大小，取值范围是 1 至 40，最小尺寸 1 会生成 21 * 21 的二维码，version 每增加 1，生成的二维码就会添加 4 尺寸，例如 version 是 2，则生成 25 * 25 的二维码。\n\n* 参数 error_correction 指定二维码的容错系数，分别有以下4个系数：\n* ERROR_CORRECT_L: 7%的字码可被容错\n* ERROR_CORRECT_M: 15%的字码可被容错\n* ERROR_CORRECT_Q: 25%的字码可被容错\n* ERROR_CORRECT_H: 30%的字码可被容错\n* 参数 box_size 表示二维码里每个格子的像素大小。\n* 参数 border 表示边框的格子厚度是多少（默认是4）。\n","source":"_posts/Python批量生成二维码.md","raw":"---\ntitle: Python批量生成二维码\ndate: 2017-11-04 14:54:31\nauthor: \"chenJF\"\ntags:\n    - Python\narchives: Python\n---\n# Python2.7 批量生成二维\n\n## 导语：\n> 本文针对mac电脑利用Python2.7脚本批量生成二维码，由于Python生成二维码利用了qrcode和image库，需要先用pip安装这两个库。这里顺便说了下pip的安装。\n\n\n### 1.pip的安装\n* 用命令行安装pip\n~~~\nsudo easy_install pip\n~~~\n* 检查是否安装成功，只要不是not found pip，则安装成功\n~~~\npip help\n~~~\n<br>\n### 2.安装qrcode和image库\n* 安装命令\n~~~\n#安装失败可以加sudo安装\npip install qrcode\npip install image\n~~~\n* 检查是否安装成功,安装成功会有相应的版本信息\n~~~\npip show qrcode\npip show image\n~~~\n* 安装成功显示界面信息\n\n* ![python-qrcode.png](http://upload-images.jianshu.io/upload_images/4970496-ce568913bd5e15a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n<br>\n### 3.示例代码\n~~~\n# 导入qrcode库\nimport qrcode\n\n#生成一张二维码图片，url二维码的内容，name保存二维码图片的名字\ndef createOneQR(url,name):\nqr=qrcode.QRCode(version = 2,\nerror_correction = qrcode.constants.ERROR_CORRECT_L, #容错样式\nbox_size=10,   #每个格子的像素\nborder=1)      #边框宽度\nqr.add_data(url)\nqr.make(fit=True)\nimg = qr.make_image()\nimg.resize((140, 140)).save(name)   #保存为140*140的图片\n\n\n#根据文档批量生成二维码\ndef getQR():\nnum = 0\n#遍历文档每行内容生成二维码\nfor line in open(\"license-for-card.txt\"):\nimageName = \"license\"+str(num)+\".png\"\ncreateOneQR(line,imageName)\nnum += 1\n\ngetQR()\n~~~\n\n* 参数 version 表示生成二维码的尺寸大小，取值范围是 1 至 40，最小尺寸 1 会生成 21 * 21 的二维码，version 每增加 1，生成的二维码就会添加 4 尺寸，例如 version 是 2，则生成 25 * 25 的二维码。\n\n* 参数 error_correction 指定二维码的容错系数，分别有以下4个系数：\n* ERROR_CORRECT_L: 7%的字码可被容错\n* ERROR_CORRECT_M: 15%的字码可被容错\n* ERROR_CORRECT_Q: 25%的字码可被容错\n* ERROR_CORRECT_H: 30%的字码可被容错\n* 参数 box_size 表示二维码里每个格子的像素大小。\n* 参数 border 表示边框的格子厚度是多少（默认是4）。\n","slug":"Python批量生成二维码","published":1,"updated":"2018-03-16T01:21:56.663Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjetk9bbx0006o5fyipiitok2","content":"<h1 id=\"Python2-7-批量生成二维\"><a href=\"#Python2-7-批量生成二维\" class=\"headerlink\" title=\"Python2.7 批量生成二维\"></a>Python2.7 批量生成二维</h1><h2 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h2><blockquote>\n<p>本文针对mac电脑利用Python2.7脚本批量生成二维码，由于Python生成二维码利用了qrcode和image库，需要先用pip安装这两个库。这里顺便说了下pip的安装。</p>\n</blockquote>\n<h3 id=\"1-pip的安装\"><a href=\"#1-pip的安装\" class=\"headerlink\" title=\"1.pip的安装\"></a>1.pip的安装</h3><ul>\n<li><p>用命令行安装pip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo easy_install pip</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查是否安装成功，只要不是not found pip，则安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pip help</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"2-安装qrcode和image库\"><a href=\"#2-安装qrcode和image库\" class=\"headerlink\" title=\"2.安装qrcode和image库\"></a>2.安装qrcode和image库</h3><ul>\n<li><p>安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#安装失败可以加sudo安装</div><div class=\"line\">pip install qrcode</div><div class=\"line\">pip install image</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查是否安装成功,安装成功会有相应的版本信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pip show qrcode</div><div class=\"line\">pip show image</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装成功显示界面信息</p>\n</li>\n<li><p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-ce568913bd5e15a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"python-qrcode.png\"><br><br></p>\n<h3 id=\"3-示例代码\"><a href=\"#3-示例代码\" class=\"headerlink\" title=\"3.示例代码\"></a>3.示例代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"># 导入qrcode库</div><div class=\"line\">import qrcode</div><div class=\"line\"></div><div class=\"line\">#生成一张二维码图片，url二维码的内容，name保存二维码图片的名字</div><div class=\"line\">def createOneQR(url,name):</div><div class=\"line\">qr=qrcode.QRCode(version = 2,</div><div class=\"line\">error_correction = qrcode.constants.ERROR_CORRECT_L, #容错样式</div><div class=\"line\">box_size=10,   #每个格子的像素</div><div class=\"line\">border=1)      #边框宽度</div><div class=\"line\">qr.add_data(url)</div><div class=\"line\">qr.make(fit=True)</div><div class=\"line\">img = qr.make_image()</div><div class=\"line\">img.resize((140, 140)).save(name)   #保存为140*140的图片</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#根据文档批量生成二维码</div><div class=\"line\">def getQR():</div><div class=\"line\">num = 0</div><div class=\"line\">#遍历文档每行内容生成二维码</div><div class=\"line\">for line in open(&quot;license-for-card.txt&quot;):</div><div class=\"line\">imageName = &quot;license&quot;+str(num)+&quot;.png&quot;</div><div class=\"line\">createOneQR(line,imageName)</div><div class=\"line\">num += 1</div><div class=\"line\"></div><div class=\"line\">getQR()</div></pre></td></tr></table></figure>\n</li>\n<li><p>参数 version 表示生成二维码的尺寸大小，取值范围是 1 至 40，最小尺寸 1 会生成 21 <em> 21 的二维码，version 每增加 1，生成的二维码就会添加 4 尺寸，例如 version 是 2，则生成 25 </em> 25 的二维码。</p>\n</li>\n<li><p>参数 error_correction 指定二维码的容错系数，分别有以下4个系数：</p>\n</li>\n<li>ERROR_CORRECT_L: 7%的字码可被容错</li>\n<li>ERROR_CORRECT_M: 15%的字码可被容错</li>\n<li>ERROR_CORRECT_Q: 25%的字码可被容错</li>\n<li>ERROR_CORRECT_H: 30%的字码可被容错</li>\n<li>参数 box_size 表示二维码里每个格子的像素大小。</li>\n<li>参数 border 表示边框的格子厚度是多少（默认是4）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Python2-7-批量生成二维\"><a href=\"#Python2-7-批量生成二维\" class=\"headerlink\" title=\"Python2.7 批量生成二维\"></a>Python2.7 批量生成二维</h1><h2 id=\"导语：\"><a href=\"#导语：\" class=\"headerlink\" title=\"导语：\"></a>导语：</h2><blockquote>\n<p>本文针对mac电脑利用Python2.7脚本批量生成二维码，由于Python生成二维码利用了qrcode和image库，需要先用pip安装这两个库。这里顺便说了下pip的安装。</p>\n</blockquote>\n<h3 id=\"1-pip的安装\"><a href=\"#1-pip的安装\" class=\"headerlink\" title=\"1.pip的安装\"></a>1.pip的安装</h3><ul>\n<li><p>用命令行安装pip</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">sudo easy_install pip</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查是否安装成功，只要不是not found pip，则安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pip help</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p><br></p>\n<h3 id=\"2-安装qrcode和image库\"><a href=\"#2-安装qrcode和image库\" class=\"headerlink\" title=\"2.安装qrcode和image库\"></a>2.安装qrcode和image库</h3><ul>\n<li><p>安装命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">#安装失败可以加sudo安装</div><div class=\"line\">pip install qrcode</div><div class=\"line\">pip install image</div></pre></td></tr></table></figure>\n</li>\n<li><p>检查是否安装成功,安装成功会有相应的版本信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\">pip show qrcode</div><div class=\"line\">pip show image</div></pre></td></tr></table></figure>\n</li>\n<li><p>安装成功显示界面信息</p>\n</li>\n<li><p><img src=\"http://upload-images.jianshu.io/upload_images/4970496-ce568913bd5e15a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" alt=\"python-qrcode.png\"><br><br></p>\n<h3 id=\"3-示例代码\"><a href=\"#3-示例代码\" class=\"headerlink\" title=\"3.示例代码\"></a>3.示例代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><div class=\"line\"># 导入qrcode库</div><div class=\"line\">import qrcode</div><div class=\"line\"></div><div class=\"line\">#生成一张二维码图片，url二维码的内容，name保存二维码图片的名字</div><div class=\"line\">def createOneQR(url,name):</div><div class=\"line\">qr=qrcode.QRCode(version = 2,</div><div class=\"line\">error_correction = qrcode.constants.ERROR_CORRECT_L, #容错样式</div><div class=\"line\">box_size=10,   #每个格子的像素</div><div class=\"line\">border=1)      #边框宽度</div><div class=\"line\">qr.add_data(url)</div><div class=\"line\">qr.make(fit=True)</div><div class=\"line\">img = qr.make_image()</div><div class=\"line\">img.resize((140, 140)).save(name)   #保存为140*140的图片</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">#根据文档批量生成二维码</div><div class=\"line\">def getQR():</div><div class=\"line\">num = 0</div><div class=\"line\">#遍历文档每行内容生成二维码</div><div class=\"line\">for line in open(&quot;license-for-card.txt&quot;):</div><div class=\"line\">imageName = &quot;license&quot;+str(num)+&quot;.png&quot;</div><div class=\"line\">createOneQR(line,imageName)</div><div class=\"line\">num += 1</div><div class=\"line\"></div><div class=\"line\">getQR()</div></pre></td></tr></table></figure>\n</li>\n<li><p>参数 version 表示生成二维码的尺寸大小，取值范围是 1 至 40，最小尺寸 1 会生成 21 <em> 21 的二维码，version 每增加 1，生成的二维码就会添加 4 尺寸，例如 version 是 2，则生成 25 </em> 25 的二维码。</p>\n</li>\n<li><p>参数 error_correction 指定二维码的容错系数，分别有以下4个系数：</p>\n</li>\n<li>ERROR_CORRECT_L: 7%的字码可被容错</li>\n<li>ERROR_CORRECT_M: 15%的字码可被容错</li>\n<li>ERROR_CORRECT_Q: 25%的字码可被容错</li>\n<li>ERROR_CORRECT_H: 30%的字码可被容错</li>\n<li>参数 box_size 表示二维码里每个格子的像素大小。</li>\n<li>参数 border 表示边框的格子厚度是多少（默认是4）。</li>\n</ul>\n"},{"title":"软件设计师考点内容(二)","date":"2018-03-16T03:00:00.000Z","author":"chenJF","archives":"软考","_content":"\n# 软件设计师考点内容分析\n\n### 1.软件质量特性\n  * 功能性：适合性、准确性、互操作性、保密安全性、功能依从性。\n  * 可靠性：成熟性、容错性、易恢复性、可靠依从性。\n  * 易用性：易理解性、易操作性、易学性、吸引性、易用依从性。\n  * 效率：时间特性、资源利用、效率依从性。\n  * 维护性：易分析性、易改变性、稳定性、易测试性、维护依从性。\n  * 可移植性：适用性、易安装性、共存性、易替换性、可移植性的依从性。\n\n### 2.环形复杂度计算\n* 环形复杂度V(G) = E - N + 2\n(E是流图中的边的条数，N是节点数)\n\n### 3.内聚类型\n* ① 偶然内聚：模块中的代码无法定义其不同功能的调用。但它使该模块能执行不同的功能，这种模块称为巧合强度模块。\n* ② 逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能\n* ③ 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。\n* ④ 过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。\n* ⑤ 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。\n* ⑥ 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。即一个模块完成多个功能，这些模块又必须顺序执行。\n* ⑦ 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，联系紧密，缺一不可。\n\n### 4.UML状态图的转换(transition)的五要素\n* 源状态：即受转换影响的状态。\n* 目标状态：当转换完成后对象的状态。\n* 触发事件：用来为转换定义一个事件，包括调用、改变、信号、时间四类事件。\n* 监护条件：布尔表达式，决定是否激活转换。\n* 动作：转换激活时的操作。\n\n### 5.策略模式\n策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以互相替换。策略模式让算法独立于它的客户而独立变换。\n应用场景：\n* 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。\n* 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。\n* 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。\n\n### 6.生成器模式\n生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n适用范围：\n* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。\n* 当构造过程必须允许被构造的对象有不同表示时。\n\n### 7.乔姆斯基（chomsky）文法分类\n* 0型文法(短语结构文法)：0型文法的能力相当于图灵机(Turing)。或者说，任何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个，所以我们在试题中见到的,至少是0型文法。\n* 1型文法(上下文有关文法)：此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|≥|α|。这里的|β|表示的是β的长度。\n* 2型文法(上下文无关文法)：此文发对应于下推自动机，形式语言论中一种重要的变换文法，用来描述上下文无关语言。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。2型文法是在1型文法的基础上,再满足：每一个α→β都有α是非终结符。如A->Ba,符合2型文法要求。\n* 3型文法(正规文法)：此文发对应于有限状态自动机。它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。","source":"_posts/软件设计师考点内容-二.md","raw":"---\ntitle: 软件设计师考点内容(二)\ndate: 2018-03-16 11:00:00\nauthor: \"chenJF\"\ntags: 软件设计师\narchives: 软考\n---\n\n# 软件设计师考点内容分析\n\n### 1.软件质量特性\n  * 功能性：适合性、准确性、互操作性、保密安全性、功能依从性。\n  * 可靠性：成熟性、容错性、易恢复性、可靠依从性。\n  * 易用性：易理解性、易操作性、易学性、吸引性、易用依从性。\n  * 效率：时间特性、资源利用、效率依从性。\n  * 维护性：易分析性、易改变性、稳定性、易测试性、维护依从性。\n  * 可移植性：适用性、易安装性、共存性、易替换性、可移植性的依从性。\n\n### 2.环形复杂度计算\n* 环形复杂度V(G) = E - N + 2\n(E是流图中的边的条数，N是节点数)\n\n### 3.内聚类型\n* ① 偶然内聚：模块中的代码无法定义其不同功能的调用。但它使该模块能执行不同的功能，这种模块称为巧合强度模块。\n* ② 逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能\n* ③ 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。\n* ④ 过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。\n* ⑤ 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。\n* ⑥ 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。即一个模块完成多个功能，这些模块又必须顺序执行。\n* ⑦ 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，联系紧密，缺一不可。\n\n### 4.UML状态图的转换(transition)的五要素\n* 源状态：即受转换影响的状态。\n* 目标状态：当转换完成后对象的状态。\n* 触发事件：用来为转换定义一个事件，包括调用、改变、信号、时间四类事件。\n* 监护条件：布尔表达式，决定是否激活转换。\n* 动作：转换激活时的操作。\n\n### 5.策略模式\n策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以互相替换。策略模式让算法独立于它的客户而独立变换。\n应用场景：\n* 多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。\n* 需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。\n* 对客户隐藏具体策略(算法)的实现细节，彼此完全独立。\n\n### 6.生成器模式\n生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。\n适用范围：\n* 当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。\n* 当构造过程必须允许被构造的对象有不同表示时。\n\n### 7.乔姆斯基（chomsky）文法分类\n* 0型文法(短语结构文法)：0型文法的能力相当于图灵机(Turing)。或者说，任何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个，所以我们在试题中见到的,至少是0型文法。\n* 1型文法(上下文有关文法)：此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|≥|α|。这里的|β|表示的是β的长度。\n* 2型文法(上下文无关文法)：此文发对应于下推自动机，形式语言论中一种重要的变换文法，用来描述上下文无关语言。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。2型文法是在1型文法的基础上,再满足：每一个α→β都有α是非终结符。如A->Ba,符合2型文法要求。\n* 3型文法(正规文法)：此文发对应于有限状态自动机。它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。","slug":"软件设计师考点内容-二","published":1,"updated":"2018-03-16T03:30:43.882Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjetk9bbz0007o5fye12iqfn0","content":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1-软件质量特性\"><a href=\"#1-软件质量特性\" class=\"headerlink\" title=\"1.软件质量特性\"></a>1.软件质量特性</h3><ul>\n<li>功能性：适合性、准确性、互操作性、保密安全性、功能依从性。</li>\n<li>可靠性：成熟性、容错性、易恢复性、可靠依从性。</li>\n<li>易用性：易理解性、易操作性、易学性、吸引性、易用依从性。</li>\n<li>效率：时间特性、资源利用、效率依从性。</li>\n<li>维护性：易分析性、易改变性、稳定性、易测试性、维护依从性。</li>\n<li>可移植性：适用性、易安装性、共存性、易替换性、可移植性的依从性。</li>\n</ul>\n<h3 id=\"2-环形复杂度计算\"><a href=\"#2-环形复杂度计算\" class=\"headerlink\" title=\"2.环形复杂度计算\"></a>2.环形复杂度计算</h3><ul>\n<li>环形复杂度V(G) = E - N + 2<br>(E是流图中的边的条数，N是节点数)</li>\n</ul>\n<h3 id=\"3-内聚类型\"><a href=\"#3-内聚类型\" class=\"headerlink\" title=\"3.内聚类型\"></a>3.内聚类型</h3><ul>\n<li>① 偶然内聚：模块中的代码无法定义其不同功能的调用。但它使该模块能执行不同的功能，这种模块称为巧合强度模块。</li>\n<li>② 逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能</li>\n<li>③ 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。</li>\n<li>④ 过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。</li>\n<li>⑤ 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。</li>\n<li>⑥ 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。即一个模块完成多个功能，这些模块又必须顺序执行。</li>\n<li>⑦ 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，联系紧密，缺一不可。</li>\n</ul>\n<h3 id=\"4-UML状态图的转换-transition-的五要素\"><a href=\"#4-UML状态图的转换-transition-的五要素\" class=\"headerlink\" title=\"4.UML状态图的转换(transition)的五要素\"></a>4.UML状态图的转换(transition)的五要素</h3><ul>\n<li>源状态：即受转换影响的状态。</li>\n<li>目标状态：当转换完成后对象的状态。</li>\n<li>触发事件：用来为转换定义一个事件，包括调用、改变、信号、时间四类事件。</li>\n<li>监护条件：布尔表达式，决定是否激活转换。</li>\n<li>动作：转换激活时的操作。</li>\n</ul>\n<h3 id=\"5-策略模式\"><a href=\"#5-策略模式\" class=\"headerlink\" title=\"5.策略模式\"></a>5.策略模式</h3><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以互相替换。策略模式让算法独立于它的客户而独立变换。<br>应用场景：</p>\n<ul>\n<li>多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li>\n<li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li>\n<li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li>\n</ul>\n<h3 id=\"6-生成器模式\"><a href=\"#6-生成器模式\" class=\"headerlink\" title=\"6.生成器模式\"></a>6.生成器模式</h3><p>生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>适用范围：</p>\n<ul>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>\n<li>当构造过程必须允许被构造的对象有不同表示时。</li>\n</ul>\n<h3 id=\"7-乔姆斯基（chomsky）文法分类\"><a href=\"#7-乔姆斯基（chomsky）文法分类\" class=\"headerlink\" title=\"7.乔姆斯基（chomsky）文法分类\"></a>7.乔姆斯基（chomsky）文法分类</h3><ul>\n<li>0型文法(短语结构文法)：0型文法的能力相当于图灵机(Turing)。或者说，任何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个，所以我们在试题中见到的,至少是0型文法。</li>\n<li>1型文法(上下文有关文法)：此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|≥|α|。这里的|β|表示的是β的长度。</li>\n<li>2型文法(上下文无关文法)：此文发对应于下推自动机，形式语言论中一种重要的变换文法，用来描述上下文无关语言。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。2型文法是在1型文法的基础上,再满足：每一个α→β都有α是非终结符。如A-&gt;Ba,符合2型文法要求。</li>\n<li>3型文法(正规文法)：此文发对应于有限状态自动机。它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"软件设计师考点内容分析\"><a href=\"#软件设计师考点内容分析\" class=\"headerlink\" title=\"软件设计师考点内容分析\"></a>软件设计师考点内容分析</h1><h3 id=\"1-软件质量特性\"><a href=\"#1-软件质量特性\" class=\"headerlink\" title=\"1.软件质量特性\"></a>1.软件质量特性</h3><ul>\n<li>功能性：适合性、准确性、互操作性、保密安全性、功能依从性。</li>\n<li>可靠性：成熟性、容错性、易恢复性、可靠依从性。</li>\n<li>易用性：易理解性、易操作性、易学性、吸引性、易用依从性。</li>\n<li>效率：时间特性、资源利用、效率依从性。</li>\n<li>维护性：易分析性、易改变性、稳定性、易测试性、维护依从性。</li>\n<li>可移植性：适用性、易安装性、共存性、易替换性、可移植性的依从性。</li>\n</ul>\n<h3 id=\"2-环形复杂度计算\"><a href=\"#2-环形复杂度计算\" class=\"headerlink\" title=\"2.环形复杂度计算\"></a>2.环形复杂度计算</h3><ul>\n<li>环形复杂度V(G) = E - N + 2<br>(E是流图中的边的条数，N是节点数)</li>\n</ul>\n<h3 id=\"3-内聚类型\"><a href=\"#3-内聚类型\" class=\"headerlink\" title=\"3.内聚类型\"></a>3.内聚类型</h3><ul>\n<li>① 偶然内聚：模块中的代码无法定义其不同功能的调用。但它使该模块能执行不同的功能，这种模块称为巧合强度模块。</li>\n<li>② 逻辑内聚：这种模块把几种相关的功能组合在一起， 每次被调用时，由传送给模块参数来确定该模块应完成哪一种功能</li>\n<li>③ 时间内聚：把需要同时执行的动作组合在一起形成的模块为时间内聚模块。</li>\n<li>④ 过程内聚：构件或者操作的组合方式是，允许在调用前面的构件或操作之后，马上调用后面的构件或操作，即使两者之间没有数据进行传递。</li>\n<li>⑤ 通信内聚：指模块内所有处理元素都在同一个数据结构上操作（有时称之为信息内聚），或者指各处理使用相同的输入数据或者产生相同的输出数据。</li>\n<li>⑥ 顺序内聚：指一个模块中各个处理元素都密切相关于同一功能且必须顺序执行，前一功能元素输出就是下一功能元素的输入。即一个模块完成多个功能，这些模块又必须顺序执行。</li>\n<li>⑦ 功能内聚：这是最强的内聚，指模块内所有元素共同完成一个功能，联系紧密，缺一不可。</li>\n</ul>\n<h3 id=\"4-UML状态图的转换-transition-的五要素\"><a href=\"#4-UML状态图的转换-transition-的五要素\" class=\"headerlink\" title=\"4.UML状态图的转换(transition)的五要素\"></a>4.UML状态图的转换(transition)的五要素</h3><ul>\n<li>源状态：即受转换影响的状态。</li>\n<li>目标状态：当转换完成后对象的状态。</li>\n<li>触发事件：用来为转换定义一个事件，包括调用、改变、信号、时间四类事件。</li>\n<li>监护条件：布尔表达式，决定是否激活转换。</li>\n<li>动作：转换激活时的操作。</li>\n</ul>\n<h3 id=\"5-策略模式\"><a href=\"#5-策略模式\" class=\"headerlink\" title=\"5.策略模式\"></a>5.策略模式</h3><p>策略模式定义了一系列的算法，并将每一个算法封装起来，而且使它们还可以互相替换。策略模式让算法独立于它的客户而独立变换。<br>应用场景：</p>\n<ul>\n<li>多个类只区别在表现行为不同，可以使用Strategy模式，在运行时动态选择具体要执行的行为。</li>\n<li>需要在不同情况下使用不同的策略(算法)，或者策略还可能在未来用其它方式来实现。</li>\n<li>对客户隐藏具体策略(算法)的实现细节，彼此完全独立。</li>\n</ul>\n<h3 id=\"6-生成器模式\"><a href=\"#6-生成器模式\" class=\"headerlink\" title=\"6.生成器模式\"></a>6.生成器模式</h3><p>生成器模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。<br>适用范围：</p>\n<ul>\n<li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。</li>\n<li>当构造过程必须允许被构造的对象有不同表示时。</li>\n</ul>\n<h3 id=\"7-乔姆斯基（chomsky）文法分类\"><a href=\"#7-乔姆斯基（chomsky）文法分类\" class=\"headerlink\" title=\"7.乔姆斯基（chomsky）文法分类\"></a>7.乔姆斯基（chomsky）文法分类</h3><ul>\n<li>0型文法(短语结构文法)：0型文法的能力相当于图灵机(Turing)。或者说，任何0型文语言都是递归可枚举的，反之，递归可枚举集必定是一个0型语言。0型文法是这几类文法中，限制最少的一个，所以我们在试题中见到的,至少是0型文法。</li>\n<li>1型文法(上下文有关文法)：此文法对应于线性有界自动机。它是在0型文法的基础上每一个α→β,都有|β|≥|α|。这里的|β|表示的是β的长度。</li>\n<li>2型文法(上下文无关文法)：此文发对应于下推自动机，形式语言论中一种重要的变换文法，用来描述上下文无关语言。由于程序设计语言的语法基本上都是上下文无关文法，因此应用十分广泛。2型文法是在1型文法的基础上,再满足：每一个α→β都有α是非终结符。如A-&gt;Ba,符合2型文法要求。</li>\n<li>3型文法(正规文法)：此文发对应于有限状态自动机。它是在2型文法的基础上满足:A→α|αB（右线性）或A→α|Bα（左线性）。</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cjetk9bb70000o5fynie56d8z","tag_id":"cjetk9bbk0004o5fypt23ufdh","_id":"cjetk9bc20009o5fy0z44prk8"},{"post_id":"cjetk9bbz0007o5fye12iqfn0","tag_id":"cjetk9bbk0004o5fypt23ufdh","_id":"cjetk9bc3000ao5fy522y7aex"},{"post_id":"cjetk9bbe0002o5fy505acw83","tag_id":"cjetk9bbk0004o5fypt23ufdh","_id":"cjetk9bc3000co5fydsvbv05z"},{"post_id":"cjetk9bbm0005o5fyfrs0xo8j","tag_id":"cjetk9bc3000bo5fytwhijhg0","_id":"cjetk9bc4000eo5fy4tb1jn9g"},{"post_id":"cjetk9bbx0006o5fyipiitok2","tag_id":"cjetk9bc3000do5fy135qmyt6","_id":"cjetk9bc4000fo5fyfnxx8wvq"}],"Tag":[{"name":"软件设计师","_id":"cjetk9bbk0004o5fypt23ufdh"},{"name":"git","_id":"cjetk9bc3000bo5fytwhijhg0"},{"name":"Python","_id":"cjetk9bc3000do5fy135qmyt6"}]}}